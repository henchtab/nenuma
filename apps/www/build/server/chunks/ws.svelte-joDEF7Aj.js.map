{"version":3,"file":"ws.svelte-joDEF7Aj.js","sources":["../../../../src/lib/stores/ws.svelte.ts"],"sourcesContent":["import { browser } from '$app/environment';\nimport { PUBLIC_API_URL } from '$env/static/public';\nimport type { UTCTimestamp } from 'lightweight-charts';\nimport { writable } from 'svelte/store';\nimport { timeToLocal } from '../utils';\n\nconst WS_DISCONNECT_RETRY_INTERVAL = 1000;\n\ntype Ws = {\n  send: WebSocket['send'];\n  close: WebSocket['close'];\n  addEventListener: WebSocket['addEventListener'];\n  reconnect: () => void;\n  isConnected: boolean;\n  isError: boolean;\n  currentMessage: WsMessage | null;\n};\n\nconst initialState: Ws = {\n  send: () => {\n    console.error('WebSocket connection not established');\n  },\n  close: () => {\n    console.error('WebSocket connection not established');\n  },\n  addEventListener: () => {\n    console.error('WebSocket connection not established');\n  },\n  reconnect: () => {\n    console.error('WebSocket connection not established');\n  },\n  isConnected: false,\n  isError: false,\n  currentMessage: null\n};\n\nexport const ws = writable(initialState, (set) => {\n  if (!browser) {\n    return;\n  }\n\n  let ws: WebSocket | null = $state(null);\n\n  let isConnected = $state(false);\n  let isError = $state(false);\n  let lastMessage: WsMessage | null = $state(null);\n\n  function update() {\n    if (!browser) {\n      return;\n    }\n\n    ws = new WebSocket(\n      `${PUBLIC_API_URL.replace('https', 'wss')}/api/kline`\n    );\n\n    ws?.addEventListener('open', () => {\n      isConnected = true;\n    });\n\n    ws?.addEventListener('message', (event) => {\n      const message = JSON.parse(event.data) as WsMessage;\n      message.data.time = timeToLocal(message.data.time as number) as UTCTimestamp;\n      lastMessage = message;\n\n      latestPrices.update((prices) => {\n        prices[message.topic] = message.data.close;\n        return prices;\n      });\n    });\n\n    ws?.addEventListener('close', (e) => {\n      console.log(`WebSocket connection closed with code: ${e.code} and reason: ${e.reason}`);\n      set(initialState);\n    });\n\n    ws.addEventListener('error', (e) => {\n      console.error('WebSocket error:', e);\n      isError = true;\n      set(initialState);\n    });\n\n    set({\n      send: ws.send.bind(ws),\n      close: ws.close.bind(ws),\n      addEventListener: ws.addEventListener.bind(ws),\n      reconnect: update,\n      get isConnected() {\n        return isConnected;\n      },\n      get isError() {\n        return isError;\n      },\n      get currentMessage() {\n        return lastMessage;\n      }\n    });\n  }\n\n  function cleanup() {\n    if (ws?.bufferedAmount === 0) {\n      ws?.close(1000, 'User closed the connection');\n    } else {\n      setTimeout(cleanup, WS_DISCONNECT_RETRY_INTERVAL);\n    }\n  }\n\n  update();\n\n  return cleanup;\n});\n\nexport enum KlineTopic {\n  BTCUSDT = 'BTCUSDT',\n  ETHUSDT = 'ETHUSDT',\n  SOLUSDT = 'SOLUSDT',\n  TONUSDT = 'TONUSDT',\n  BNBUSDT = 'BNBUSDT'\n}\n\nexport type WsMessage = {\n  topic: KlineTopic;\n  data: {\n    open: number;\n    close: number;\n    high: number;\n    low: number;\n    time: UTCTimestamp;\n  };\n};\n\nexport const latestPrices = writable<Record<KlineTopic, number>>({\n  [KlineTopic.BTCUSDT]: 0,\n  [KlineTopic.ETHUSDT]: 0,\n  [KlineTopic.SOLUSDT]: 0,\n  [KlineTopic.TONUSDT]: 0,\n  [KlineTopic.BNBUSDT]: 0\n});\n"],"names":["KlineTopic"],"mappings":";;;;;;;;;;;;;AAgHA,IAAY,UAAZ,mBAAA,CAAA,CAAYA,WAAZ,KAAO;AACLA,EAAFA,WAAAA,CAAE,SAAU,CAAZA,GAAY,SAAZA,CAAAA;AACEA,EAAFA,WAAAA,CAAE,SAAU,CAAZA,GAAY,SAAZA,CAAAA;AACEA,EAAFA,WAAAA,CAAE,SAAU,CAAZA,GAAY,SAAZA,CAAAA;AACEA,EAAFA,WAAAA,CAAE,SAAU,CAAZA,GAAY,SAAZA,CAAAA;AACEA,EAAFA,WAAAA,CAAE,SAAU,CAAZA,GAAY,SAAZA,CAAAA;AALAA,EAAAA,OAAYA,WAAZA,CAAAA;AAAA,CAAA,EAAY,UAAZ,IAAY,EAAA,EAAZ;AAmBA,MAAa,YAAb,GAA4B,QAA5B,CAAiE;AAAA,EAC9D,CAAA,SADH,GACwB,CADxB;AACwB;AAAA,EACrB,CAAA,SADH,GACwB,CADxB;AACwB;AAAA,EACrB,CAAA,SADH,GACwB,CADxB;AACwB;AAAA,EACrB,CAAA,SADH,GACwB,CADxB;AACwB;AAAA,EACrB,CAAA,SADH,GACwB,CADxB;AACwB;;;;;"}