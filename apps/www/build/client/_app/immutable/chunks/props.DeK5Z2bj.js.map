{"version":3,"file":"props.DeK5Z2bj.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/reactivity/props.js"],"sourcesContent":["import { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../utils.js';\nimport { mutable_source, set, source } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, is_signals_recorded, untrack, update } from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { LEGACY_DERIVED_PROP } from '../constants.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: import('./types.js').Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return get_descriptor(p, key);\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\n\tvar prop_value = /** @type {V} */ (props[key]);\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\n\tvar get_fallback = () => {\n\t\tif (lazy && fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\tvar current = get(current_value);\n\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\tget(current_value); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\treturn current;\n\t};\n}\n"],"names":["rest_props_handler","target","key","rest_props","props","exclude","name","legacy_rest_props_handler","get","value","prop","PROPS_IS_UPDATED","update","legacy_rest_props","source","spread_props_handler","i","p","is_function","get_descriptor","keys","spread_props","flags","fallback","immutable","PROPS_IS_IMMUTABLE","runes","PROPS_IS_RUNES","lazy","PROPS_IS_LAZY_INITIAL","prop_value","setter","_a","fallback_value","fallback_dirty","get_fallback","untrack","e.props_invalid_value","getter","derived_getter","derived","derived_safe_equal","LEGACY_DERIVED_PROP","legacy_parent","mutation","from_child","inner_current_value","mutable_source","current_value","parent_value","child_value","safe_equals","current","new_value","set"],"mappings":"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"}