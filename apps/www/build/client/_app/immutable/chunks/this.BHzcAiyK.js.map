{"version":3,"file":"this.BHzcAiyK.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/proxy.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/elements/bindings/this.js"],"sourcesContent":["import { DEV } from 'esm-env';\nimport { get, current_component_context, untrack, current_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tdefine_property,\n\tget_descriptor,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_array,\n\tis_frozen,\n\tobject_prototype\n} from './utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { mutable_source, source, set } from './reactivity/sources.js';\nimport { STATE_FROZEN_SYMBOL, STATE_SYMBOL } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {boolean} [immutable]\n * @param {import('#client').ProxyMetadata | null} [parent]\n * @param {import('#client').Source<T>} [prev] dev mode only\n * @returns {import('#client').ProxyStateObject<T> | T}\n */\nexport function proxy(value, immutable = true, parent = null, prev) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If we have an existing proxy, return it...\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tconst metadata = /** @type {import('#client').ProxyMetadata<T>} */ (value[STATE_SYMBOL]);\n\n\t\t\t// ...unless the proxy belonged to a different object, because\n\t\t\t// someone copied the state symbol using `Reflect.ownKeys(...)`\n\t\t\tif (metadata.t === value || metadata.p === value) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\t// Since original parent relationship gets lost, we need to copy over ancestor owners\n\t\t\t\t\t// into current metadata. The object might still exist on both, so we need to widen it.\n\t\t\t\t\twiden_ownership(metadata, metadata);\n\t\t\t\t\tmetadata.parent = parent;\n\t\t\t\t}\n\n\t\t\t\treturn metadata.p;\n\t\t\t}\n\t\t}\n\n\t\tconst prototype = get_prototype_of(value);\n\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tconst proxy = new Proxy(value, state_proxy_handler);\n\n\t\t\tdefine_property(value, STATE_SYMBOL, {\n\t\t\t\tvalue: /** @type {import('#client').ProxyMetadata} */ ({\n\t\t\t\t\ts: new Map(),\n\t\t\t\t\tv: source(0),\n\t\t\t\t\ta: is_array(value),\n\t\t\t\t\ti: immutable,\n\t\t\t\t\tp: proxy,\n\t\t\t\t\tt: value\n\t\t\t\t}),\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false\n\t\t\t});\n\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalue[STATE_SYMBOL].parent = parent;\n\n\t\t\t\tif (prev) {\n\t\t\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tconst prev_owners = prev?.v?.[STATE_SYMBOL]?.owners;\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners = prev_owners ? new Set(prev_owners) : null;\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners =\n\t\t\t\t\t\tparent === null\n\t\t\t\t\t\t\t? current_component_context !== null\n\t\t\t\t\t\t\t\t? new Set([current_component_context.function])\n\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t\t: new Set();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn proxy;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {import('#client').ProxyStateObject} T\n * @param {T} value\n * @param {Map<T, Record<string | symbol, any>>} already_unwrapped\n * @returns {Record<string | symbol, any>}\n */\nfunction unwrap(value, already_unwrapped) {\n\tif (typeof value === 'object' && value != null && STATE_SYMBOL in value) {\n\t\tconst unwrapped = already_unwrapped.get(value);\n\t\tif (unwrapped !== undefined) {\n\t\t\treturn unwrapped;\n\t\t}\n\n\t\tif (is_array(value)) {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst array = [];\n\t\t\talready_unwrapped.set(value, array);\n\t\t\tfor (const element of value) {\n\t\t\t\tarray.push(unwrap(element, already_unwrapped));\n\t\t\t}\n\t\t\treturn array;\n\t\t} else {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst obj = {};\n\t\t\tconst keys = Reflect.ownKeys(value);\n\t\t\tconst descriptors = get_descriptors(value);\n\t\t\talready_unwrapped.set(value, obj);\n\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (key === STATE_SYMBOL) continue;\n\t\t\t\tif (descriptors[key].get) {\n\t\t\t\t\tdefine_property(obj, key, descriptors[key]);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {T} */\n\t\t\t\t\tconst property = value[key];\n\t\t\t\t\tobj[key] = unwrap(property, already_unwrapped);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template T\n * @param {T} value\n * @returns {T}\n */\nexport function snapshot(value) {\n\treturn /** @type {T} */ (\n\t\tunwrap(/** @type {import('#client').ProxyStateObject} */ (value), new Map())\n\t);\n}\n\n/**\n * @param {import('#client').Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/** @type {ProxyHandler<import('#client').ProxyStateObject<any>>} */\nconst state_proxy_handler = {\n\tdefineProperty(target, prop, descriptor) {\n\t\tif (descriptor.value) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\t\tconst s = metadata.s.get(prop);\n\t\t\tif (s !== undefined) set(s, proxy(descriptor.value, metadata.i, metadata));\n\t\t}\n\n\t\treturn Reflect.defineProperty(target, prop, descriptor);\n\t},\n\n\tdeleteProperty(target, prop) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tconst is_array = metadata.a;\n\t\tconst boolean = delete target[prop];\n\n\t\t// If we have mutated an array directly, and the deletion\n\t\t// was successful we will also need to update the length\n\t\t// before updating the field or the version. This is to\n\t\t// ensure any effects observing length can execute before\n\t\t// effects that listen to the fields â€“ otherwise they will\n\t\t// operate an an index that no longer exists.\n\t\tif (is_array && boolean) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length - 1;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\n\t\tif (boolean) {\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn boolean;\n\t},\n\n\tget(target, prop, receiver) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn Reflect.get(target, STATE_SYMBOL);\n\t\t}\n\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\n\t\t// create a source, but only if it's an own property and not a prototype property\n\t\tif (s === undefined && (!(prop in target) || get_descriptor(target, prop)?.writable)) {\n\t\t\ts = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata));\n\t\t\tmetadata.s.set(prop, s);\n\t\t}\n\n\t\tif (s !== undefined) {\n\t\t\tconst value = get(s);\n\t\t\treturn value === UNINITIALIZED ? undefined : value;\n\t\t}\n\n\t\treturn Reflect.get(target, prop, receiver);\n\t},\n\n\tgetOwnPropertyDescriptor(target, prop) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\t\t\tconst s = metadata.s.get(prop);\n\n\t\t\tif (s) {\n\t\t\t\tdescriptor.value = get(s);\n\t\t\t}\n\t\t}\n\n\t\treturn descriptor;\n\t},\n\n\thas(target, prop) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn true;\n\t\t}\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst has = Reflect.has(target, prop);\n\n\t\tlet s = metadata.s.get(prop);\n\t\tif (\n\t\t\ts !== undefined ||\n\t\t\t(current_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t) {\n\t\t\tif (s === undefined) {\n\t\t\t\ts = (metadata.i ? source : mutable_source)(\n\t\t\t\t\thas ? proxy(target[prop], metadata.i, metadata) : UNINITIALIZED\n\t\t\t\t);\n\t\t\t\tmetadata.s.set(prop, s);\n\t\t\t}\n\t\t\tconst value = get(s);\n\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t},\n\n\tset(target, prop, value, receiver) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t// object property before writing to that property.\n\t\tif (s === undefined) {\n\t\t\t// the read creates a signal\n\t\t\tuntrack(() => receiver[prop]);\n\t\t\ts = metadata.s.get(prop);\n\t\t}\n\t\tif (s !== undefined) {\n\t\t\tset(s, proxy(value, metadata.i, metadata));\n\t\t}\n\t\tconst is_array = metadata.a;\n\t\tconst not_has = !(prop in target);\n\n\t\tif (DEV) {\n\t\t\t/** @type {import('#client').ProxyMetadata | undefined} */\n\t\t\tconst prop_metadata = value?.[STATE_SYMBOL];\n\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t}\n\t\t\tcheck_ownership(metadata);\n\t\t}\n\n\t\t// variable.length = value -> clear all signals with index >= value\n\t\tif (is_array && prop === 'length') {\n\t\t\tfor (let i = value; i < target.length; i += 1) {\n\t\t\t\tconst s = metadata.s.get(i + '');\n\t\t\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\t\t\t}\n\t\t}\n\n\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t// @ts-ignore\n\t\ttarget[prop] = value;\n\n\t\tif (not_has) {\n\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t// will not cause the length to be out of sync.\n\t\t\tif (is_array) {\n\t\t\t\tconst ls = metadata.s.get('length');\n\t\t\t\tconst length = target.length;\n\t\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\t\tset(ls, length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\townKeys(target) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\tget(metadata.v);\n\t\treturn Reflect.ownKeys(target);\n\t}\n};\n\nif (DEV) {\n\tstate_proxy_handler.setPrototypeOf = () => {\n\t\te.state_prototype_fixed();\n\t};\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\tvar metadata = value[STATE_SYMBOL];\n\t\tif (metadata) {\n\t\t\treturn metadata.p;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","import { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { hydrate_nodes, hydrating, set_hydrating } from '../hydration.js';\nimport { remove } from '../reconciler.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_END_ELSE } from '../../../../constants.js';\n\n/**\n * @param {Comment} anchor\n * @param {() => boolean} get_condition\n * @param {(anchor: Node) => import('#client').Dom} consequent_fn\n * @param {null | ((anchor: Node) => import('#client').Dom)} [alternate_fn]\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(\n\tanchor,\n\tget_condition,\n\tconsequent_fn,\n\talternate_fn = null,\n\telseif = false\n) {\n\t/** @type {import('#client').Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {import('#client').Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {boolean | null} */\n\tvar condition = null;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tblock(() => {\n\t\tif (condition === (condition = !!get_condition())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = anchor.data === HYDRATION_END_ELSE;\n\n\t\t\tif (condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tremove(hydrate_nodes);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else {\n\t\t\t\tconsequent_effect = branch(() => consequent_fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (alternate_fn) {\n\t\t\t\talternate_effect = branch(() => alternate_fn(anchor));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t}, flags);\n}\n","import { STATE_SYMBOL } from '../../../constants.js';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\t// Find the original target if the value is proxied.\n\tvar proxy_target = bound_value && bound_value[STATE_SYMBOL]?.t;\n\treturn bound_value === element_or_component || proxy_target === element_or_component;\n}\n\n/**\n * @param {Element} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n}\n"],"names":["proxy","value","immutable","parent","prev","is_frozen","STATE_FROZEN_SYMBOL","STATE_SYMBOL","metadata","prototype","get_prototype_of","object_prototype","array_prototype","state_proxy_handler","define_property","source","is_array","update_version","signal","d","set","target","prop","descriptor","s","boolean","ls","length","UNINITIALIZED","receiver","_a","get_descriptor","mutable_source","get","has","current_effect","untrack","not_has","i","if_block","anchor","get_condition","consequent_fn","alternate_fn","elseif","consequent_effect","alternate_effect","condition","flags","EFFECT_TRANSPARENT","block","mismatch","hydrating","is_else","HYDRATION_END_ELSE","remove","hydrate_nodes","set_hydrating","resume_effect","branch","pause_effect","is_bound_this","bound_value","element_or_component","proxy_target","bind_this","update","get_value","get_parts","effect","old_parts","parts","render_effect","queue_micro_task"],"mappings":"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"}