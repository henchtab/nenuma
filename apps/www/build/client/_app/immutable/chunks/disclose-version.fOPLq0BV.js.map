{"version":3,"file":"disclose-version.fOPLq0BV.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/warnings.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/hydration.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/operations.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/elements/events.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/render.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/template.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/version.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/disclose-version.js"],"sourcesContent":["/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\nvar bold = 'font-weight: bold';\nvar normal = 'font-weight: normal';\n\n/**\n * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value\n * @param {string} attribute\n * @param {string} html\n * @param {string} value\n */\nexport function hydration_attribute_changed(attribute, html, value) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] hydration_attribute_changed\\n%cThe \\`${attribute}\\` attribute on \\`${html}\\` changed its value between server and client renders. The client value, \\`${value}\\`, will be ignored in favour of the server value`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"hydration_attribute_changed\");\n\t}\n}\n\n/**\n * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%\n * @param {string | undefined | null} [location]\n */\nexport function hydration_mismatch(location) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] hydration_mismatch\\n%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : \"Hydration failed because the initial UI does not match what was rendered on the server\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"hydration_mismatch\");\n\t}\n}\n\n/**\n * Tried to unmount a component that was not mounted\n */\nexport function lifecycle_double_unmount() {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] lifecycle_double_unmount\\n%cTried to unmount a component that was not mounted`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"lifecycle_double_unmount\");\n\t}\n}\n\n/**\n * %parent% passed a value to %child% with `bind:`, but the value is owned by %owner%. Consider creating a binding between %owner% and %parent%\n * @param {string} parent\n * @param {string} child\n * @param {string} owner\n */\nexport function ownership_invalid_binding(parent, child, owner) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] ownership_invalid_binding\\n%c${parent} passed a value to ${child} with \\`bind:\\`, but the value is owned by ${owner}. Consider creating a binding between ${owner} and ${parent}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"ownership_invalid_binding\");\n\t}\n}\n\n/**\n * %component% mutated a value owned by %owner%. This is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead\n * @param {string | undefined | null} [component]\n * @param {string | undefined | null} [owner]\n */\nexport function ownership_invalid_mutation(component, owner) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] ownership_invalid_mutation\\n%c${component ? `${component} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \\`bind:\\`, or use a callback instead` : \"Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"ownership_invalid_mutation\");\n\t}\n}\n\n/**\n * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results. Consider using `$state.is(a, b)` instead\n * @param {string} operator\n */\nexport function state_proxy_equality_mismatch(operator) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] state_proxy_equality_mismatch\\n%cReactive \\`$state(...)\\` proxies and the values they proxy have different identities. Because of this, comparisons with \\`${operator}\\` will produce unexpected results. Consider using \\`$state.is(a, b)\\` instead`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"state_proxy_equality_mismatch\");\n\t}\n}","import { DEV } from 'esm-env';\nimport { HYDRATION_END, HYDRATION_START, HYDRATION_ERROR } from '../../../constants.js';\nimport * as w from '../warnings.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * Array of nodes to traverse for hydration. This will be null if we're not hydrating, but for\n * the sake of simplicity we're not going to use `null` checks everywhere and instead rely on\n * the `hydrating` flag to tell whether or not we're in hydration mode at which point this is set.\n * @type {import('#client').TemplateNode[]}\n */\nexport let hydrate_nodes = /** @type {any} */ (null);\n\n/** @type {import('#client').TemplateNode} */\nexport let hydrate_start;\n\n/** @param {import('#client').TemplateNode[]} nodes */\nexport function set_hydrate_nodes(nodes) {\n\thydrate_nodes = nodes;\n\thydrate_start = nodes && nodes[0];\n}\n\n/**\n * This function is only called when `hydrating` is true. If passed a `<!--[-->` opening\n * hydration marker, it finds the corresponding closing marker and sets `hydrate_nodes`\n * to everything between the markers, before returning the closing marker.\n * @param {Node} node\n * @returns {Node}\n */\nexport function hydrate_anchor(node) {\n\tif (node.nodeType !== 8) {\n\t\treturn node;\n\t}\n\n\tvar current = /** @type {Node | null} */ (node);\n\n\t// TODO this could have false positives, if a user comment consisted of `[`. need to tighten that up\n\tif (/** @type {Comment} */ (current).data !== HYDRATION_START) {\n\t\treturn node;\n\t}\n\n\t/** @type {Node[]} */\n\tvar nodes = [];\n\tvar depth = 0;\n\n\twhile ((current = /** @type {Node} */ (current).nextSibling) !== null) {\n\t\tif (current.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (current).data;\n\n\t\t\tif (data === HYDRATION_START) {\n\t\t\t\tdepth += 1;\n\t\t\t} else if (data[0] === HYDRATION_END) {\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\thydrate_nodes = /** @type {import('#client').TemplateNode[]} */ (nodes);\n\t\t\t\t\thydrate_start = /** @type {import('#client').TemplateNode} */ (nodes[0]);\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\n\t\t\t\tdepth -= 1;\n\t\t\t}\n\t\t}\n\n\t\tnodes.push(current);\n\t}\n\n\tlet location;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\tconst loc = node.parentNode?.__svelte_meta?.loc;\n\t\tif (loc) {\n\t\t\tlocation = `${loc.file}:${loc.line}:${loc.column}`;\n\t\t}\n\t}\n\n\tw.hydration_mismatch(location);\n\tthrow HYDRATION_ERROR;\n}\n","import { hydrate_anchor, hydrate_start, hydrating } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\nimport { current_effect } from '../runtime.js';\nimport { HYDRATION_ANCHOR } from '../../../constants.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\n\tvar element_prototype = Element.prototype;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\t// @ts-expect-error\n\telement_prototype.__attributes = null;\n\t// @ts-expect-error\n\telement_prototype.__e = undefined;\n\n\t// @ts-expect-error\n\tText.prototype.__t = undefined;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/** @returns {Text} */\nexport function empty() {\n\treturn document.createTextNode('');\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function child(node) {\n\tconst child = node.firstChild;\n\tif (!hydrating) return child;\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\treturn node.appendChild(empty());\n\t}\n\n\treturn hydrate_anchor(child);\n}\n\n/**\n * @param {DocumentFragment | import('#client').TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\treturn /** @type {DocumentFragment} */ (fragment).firstChild;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && hydrate_start?.nodeType !== 3) {\n\t\tvar text = empty();\n\t\tvar dom = /** @type {import('#client').TemplateNode[]} */ (\n\t\t\t/** @type {import('#client').Effect} */ (current_effect).dom\n\t\t);\n\n\t\tdom.unshift(text);\n\t\thydrate_start?.before(text);\n\n\t\treturn text;\n\t}\n\n\treturn hydrate_anchor(hydrate_start);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function sibling(node, is_text = false) {\n\tvar next_sibling = /** @type {import('#client').TemplateNode} */ (node.nextSibling);\n\n\tif (!hydrating) {\n\t\treturn next_sibling;\n\t}\n\n\tvar type = next_sibling.nodeType;\n\n\tif (type === 8 && /** @type {Comment} */ (next_sibling).data === HYDRATION_ANCHOR) {\n\t\treturn sibling(next_sibling, is_text);\n\t}\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = empty();\n\t\tvar dom = /** @type {import('#client').TemplateNode[]} */ (\n\t\t\t/** @type {import('#client').Effect} */ (current_effect).dom\n\t\t);\n\n\t\tdom.unshift(text);\n\t\tnext_sibling?.before(text);\n\n\t\treturn text;\n\t}\n\n\treturn hydrate_anchor(/** @type {Node} */ (next_sibling));\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n\n/** @param {string} name */\n/*#__NO_SIDE_EFFECTS__*/\nexport function create_element(name) {\n\treturn document.createElement(name);\n}\n","import { teardown } from '../../reactivity/effects.js';\nimport { all_registered_events, root_event_handles } from '../../render.js';\nimport { define_property, is_array } from '../../utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} options\n */\nexport function create_event(event_name, dom, handler, options) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn handler.call(this, event);\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events.\n\tif (event_name.startsWith('pointer') || event_name === 'wheel') {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @template {HTMLElement} Element\n * @template {keyof HTMLElementEventMap} Type\n * @overload\n * @param {Element} element\n * @param {Type} type\n * @param {(this: Element, event: HTMLElementEventMap[Type]) => any} handler\n * @param {AddEventListenerOptions} [options]\n * @returns {() => void}\n */\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @overload\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n * @returns {() => void}\n */\n\n/**\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} handler\n * @param {boolean} capture\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.parentNode || /** @type {any} */ (current_target).host || null;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-expect-error is used above\n\t\tcurrent_target = handler_element;\n\t}\n}\n","import { hydrate_anchor, hydrate_nodes, hydrating, set_hydrate_nodes } from '../hydration.js';\nimport { empty } from '../operations.js';\nimport { block } from '../../reactivity/effects.js';\nimport { HYDRATION_END, HYDRATION_START } from '../../../../constants.js';\n\n/**\n * @type {Node | undefined}\n */\nlet head_anchor;\n\nexport function reset_head_anchor() {\n\thead_anchor = undefined;\n}\n\n/**\n * @param {(anchor: Node) => import('#client').Dom | void} render_fn\n * @returns {void}\n */\nexport function head(render_fn) {\n\t// The head function may be called after the first hydration pass and ssr comment nodes may still be present,\n\t// therefore we need to skip that when we detect that we're not in hydration mode.\n\tlet previous_hydrate_nodes = null;\n\tlet was_hydrating = hydrating;\n\n\t/** @type {Comment | Text} */\n\tvar anchor;\n\n\tif (hydrating) {\n\t\tprevious_hydrate_nodes = hydrate_nodes;\n\n\t\t// There might be multiple head blocks in our app, so we need to account for each one needing independent hydration.\n\t\tif (head_anchor === undefined) {\n\t\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (document.head.firstChild);\n\t\t}\n\n\t\twhile (\n\t\t\thead_anchor.nodeType !== 8 ||\n\t\t\t/** @type {Comment} */ (head_anchor).data !== HYDRATION_START\n\t\t) {\n\t\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (head_anchor.nextSibling);\n\t\t}\n\n\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (hydrate_anchor(head_anchor));\n\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (head_anchor.nextSibling);\n\t} else {\n\t\tanchor = document.head.appendChild(empty());\n\t}\n\n\ttry {\n\t\tblock(() => render_fn(anchor));\n\t} finally {\n\t\tif (was_hydrating) {\n\t\t\tset_hydrate_nodes(/** @type {import('#client').TemplateNode[]} */ (previous_hydrate_nodes));\n\t\t}\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { clear_text_content, create_element, empty, init_operations } from './dom/operations.js';\nimport { HYDRATION_ERROR, HYDRATION_START, PassiveDelegatedEvents } from '../../constants.js';\nimport { flush_sync, push, pop, current_component_context } from './runtime.js';\nimport { effect_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_anchor,\n\thydrate_nodes,\n\thydrating,\n\tset_hydrate_nodes,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from './utils.js';\nimport { handle_event_propagation } from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { validate_component } from '../shared/validate.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * This is normally true — block effects should run their intro transitions —\n * but is false during hydration and mounting (unless `options.intro` is `true`)\n * and when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// @ts-expect-error\n\tconst prev = (text.__t ??= text.nodeValue);\n\n\tif (prev !== value) {\n\t\t// @ts-expect-error\n\t\ttext.nodeValue = text.__t = value;\n\t}\n}\n\n/**\n * @param {Comment} anchor\n * @param {void | ((anchor: Comment, slot_props: Record<string, unknown>) => void)} slot_fn\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor, slot_fn, slot_props, fallback_fn) {\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor, slot_props);\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<Props>> | import('../../index.js').Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor?: Node;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}: {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tanchor?: Node;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\tif (DEV) {\n\t\tvalidate_component(component);\n\t}\n\n\tconst anchor = options.anchor ?? options.target.appendChild(empty());\n\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\treturn flush_sync(() => _mount(component, { ...options, anchor }), false);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<Props>> | import('../../index.js').Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tif (DEV) {\n\t\tvalidate_component(component);\n\t}\n\n\tconst target = options.target;\n\tconst previous_hydrate_nodes = hydrate_nodes;\n\n\ttry {\n\t\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\t\treturn flush_sync(() => {\n\t\t\tset_hydrating(true);\n\n\t\t\tvar node = target.firstChild;\n\t\t\twhile (\n\t\t\t\tnode &&\n\t\t\t\t(node.nodeType !== 8 || /** @type {Comment} */ (node).data !== HYDRATION_START)\n\t\t\t) {\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\n\t\t\tif (!node) {\n\t\t\t\tthrow HYDRATION_ERROR;\n\t\t\t}\n\n\t\t\tconst anchor = hydrate_anchor(node);\n\t\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\t\t// flush_sync will run this callback and then synchronously run any pending effects,\n\t\t\t// which don't belong to the hydration phase anymore - therefore reset it here\n\t\t\tset_hydrating(false);\n\n\t\t\treturn instance;\n\t\t}, false);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(!!previous_hydrate_nodes);\n\t\tset_hydrate_nodes(previous_hydrate_nodes);\n\t\treset_head_anchor();\n\t}\n}\n\n/**\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<any>> | import('../../index.js').Component<any>} Component\n * @param {{\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor: Node;\n * \t\tprops?: any;\n * \t\tevents?: any;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = false }) {\n\tinit_operations();\n\n\tconst registered_events = new Set();\n\n\t/** @param {Array<string>} events */\n\tconst event_handle = (events) => {\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tconst event_name = events[i];\n\t\t\tconst passive = PassiveDelegatedEvents.includes(event_name);\n\n\t\t\tif (!registered_events.has(event_name)) {\n\t\t\t\tregistered_events.add(event_name);\n\n\t\t\t\t// Add the event listener to both the container and the document.\n\t\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t\t// the outer content stops propagation of the event.\n\t\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\n\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tlet component = undefined;\n\n\tconst unmount = effect_root(() => {\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (const event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\n\t\t\t}\n\n\t\t\troot_event_handles.delete(event_handle);\n\t\t\tmounted_components.delete(component);\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n * @param {Record<string, any>} component\n */\nexport function unmount(component) {\n\tconst fn = mounted_components.get(component);\n\tif (DEV && !fn) {\n\t\tw.lifecycle_double_unmount();\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.trace('stack trace');\n\t}\n\tfn?.();\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, any>}\n */\nexport function sanitize_slots(props) {\n\tconst sanitized = { ...props.$$slots };\n\tif (props.children) sanitized.default = props.children;\n\treturn sanitized;\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n */\nexport async function append_styles(target, style_sheet_id, styles) {\n\t// Wait a tick so that the template is added to the dom, else getRootNode() will yield wrong results\n\t// If it turns out that this results in noticeable flickering, we need to do something like doing the\n\t// append outside and adding code in mount that appends all stylesheets (similar to how we do it with event delegation)\n\tawait Promise.resolve();\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = create_element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tconst target = /** @type {Document} */ (append_styles_to).head || append_styles_to;\n\t\ttarget.appendChild(style);\n\t}\n}\n\n/**\n * @param {Node} node\n */\nfunction get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn /** @type {Document} */ (node.ownerDocument);\n}\n","import { hydrate_nodes, hydrate_start, hydrating } from './hydration.js';\nimport { empty } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { current_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\nimport { is_array } from '../utils.js';\nimport { queue_micro_task } from './task.js';\n\n/**\n * @template {import(\"#client\").TemplateNode | import(\"#client\").TemplateNode[]} T\n * @param {T} dom\n * @param {import(\"#client\").Effect} effect\n */\nexport function push_template_node(\n\tdom,\n\teffect = /** @type {import('#client').Effect} */ (current_effect)\n) {\n\tvar current_dom = effect.dom;\n\tif (current_dom === null) {\n\t\teffect.dom = dom;\n\t} else {\n\t\tif (!is_array(current_dom)) {\n\t\t\tcurrent_dom = effect.dom = [current_dom];\n\t\t}\n\n\t\tif (is_array(dom)) {\n\t\t\tcurrent_dom.push(...dom);\n\t\t} else {\n\t\t\tcurrent_dom.push(dom);\n\t\t}\n\t}\n\treturn dom;\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tpush_template_node(is_fragment ? hydrate_nodes : hydrate_start);\n\t\t\treturn hydrate_start;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tnode = create_fragment_from_html(content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (node.firstChild);\n\t\t}\n\n\t\tvar clone = use_import_node ? document.importNode(node, true) : node.cloneNode(true);\n\n\t\tpush_template_node(\n\t\t\tis_fragment\n\t\t\t\t? /** @type {import('#client').TemplateNode[]} */ ([...clone.childNodes])\n\t\t\t\t: /** @type {import('#client').TemplateNode} */ (clone)\n\t\t);\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar first = true;\n\tvar fn = template(content, flags);\n\n\treturn () => {\n\t\tif (hydrating) return fn();\n\n\t\tvar node = /** @type {Element | DocumentFragment} */ (fn());\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\trun_scripts(node);\n\t\t}\n\n\t\treturn node;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar fn = template(`<${ns}>${content}</${ns}>`, 0); // we don't need to worry about using importNode for namespaced elements\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tpush_template_node(is_fragment ? hydrate_nodes : hydrate_start);\n\t\t\treturn hydrate_start;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar wrapper = /** @type {Element} */ (fn());\n\n\t\t\tif ((flags & TEMPLATE_FRAGMENT) === 0) {\n\t\t\t\tnode = /** @type {Element} */ (wrapper.firstChild);\n\t\t\t} else {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (wrapper.firstChild) {\n\t\t\t\t\tnode.appendChild(wrapper.firstChild);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar clone = node.cloneNode(true);\n\n\t\tpush_template_node(\n\t\t\tis_fragment\n\t\t\t\t? /** @type {import('#client').TemplateNode[]} */ ([...clone.childNodes])\n\t\t\t\t: /** @type {import('#client').TemplateNode} */ (clone)\n\t\t);\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar first = true;\n\tvar fn = ns_template(content, flags);\n\n\treturn () => {\n\t\tif (hydrating) return fn();\n\n\t\tvar node = /** @type {Element | DocumentFragment} */ (fn());\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\trun_scripts(node);\n\t\t}\n\n\t\treturn node;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return;\n\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tfor (const script of scripts) {\n\t\tvar clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\t\t// If node === script tag, replaceWith will do nothing because there's no parent yet,\n\t\t// waiting until that's the case using an effect solves this.\n\t\t// Don't do it in other circumstances or we could accidentally execute scripts\n\t\t// in an adjacent @html tag that was instantiated in the meantime.\n\t\tif (script === node) {\n\t\t\tqueue_micro_task(() => script.replaceWith(clone));\n\t\t} else {\n\t\t\tscript.replaceWith(clone);\n\t\t}\n\t}\n}\n\n/**\n * @param {Text | Comment | Element} anchor\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function text(anchor) {\n\tif (!hydrating) return push_template_node(empty());\n\n\tvar node = hydrate_start;\n\n\tif (!node) {\n\t\t// if an {expression} is empty during SSR, `hydrate_nodes` will be empty.\n\t\t// we need to insert an empty text node\n\t\tanchor.before((node = empty()));\n\t}\n\n\tpush_template_node(node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tpush_template_node(hydrate_nodes);\n\t\treturn hydrate_start;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar anchor = empty();\n\tfrag.append(anchor);\n\tpush_template_node([anchor]);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) return;\n\t// We intentionally do not assign the `dom` property of the effect here because it's far too\n\t// late. If we try, we will capture additional DOM elements that we cannot control the lifecycle\n\t// for and will inevitably cause memory leaks. See https://github.com/sveltejs/svelte/pull/11832\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '5.0.0-next.166';\nexport const PUBLIC_VERSION = '5';\n","import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);\n"],"names":["hydration_mismatch","location","hydrating","set_hydrating","value","hydrate_nodes","hydrate_start","set_hydrate_nodes","nodes","hydrate_anchor","node","current","HYDRATION_START","depth","data","HYDRATION_END","w.hydration_mismatch","HYDRATION_ERROR","$window","$document","init_operations","element_prototype","empty","child","first_child","fragment","is_text","text","dom","current_effect","sibling","next_sibling","type","HYDRATION_ANCHOR","clear_text_content","create_event","event_name","handler","options","target_handler","event","handle_event_propagation","queue_micro_task","capture","passive","teardown","delegate","events","i","all_registered_events","fn","root_event_handles","handler_element","owner_document","path","_a","current_target","path_idx","handled_at","at_idx","handler_idx","define_property","throw_error","other_errors","parent_element","delegated","is_array","error","head_anchor","reset_head_anchor","head","render_fn","previous_hydrate_nodes","was_hydrating","anchor","block","should_intro","set_should_intro","set_text","slot","slot_fn","slot_props","fallback_fn","mount","component","flush_sync","_mount","hydrate","target","instance","e.hydration_failed","Component","props","context","intro","registered_events","event_handle","PassiveDelegatedEvents","array_from","unmount","effect_root","branch","push","ctx","current_component_context","pop","mounted_components","push_template_node","effect","current_dom","template","content","flags","is_fragment","TEMPLATE_FRAGMENT","use_import_node","TEMPLATE_USE_IMPORT_NODE","create_fragment_from_html","clone","ns_template","ns","wrapper","comment","frag","append","PUBLIC_VERSION"],"mappings":"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"}