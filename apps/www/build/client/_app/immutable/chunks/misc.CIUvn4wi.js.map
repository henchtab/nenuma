{"version":3,"file":"misc.CIUvn4wi.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/blocks/each.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/legacy/misc.js"],"sourcesContent":["import {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_IS_STRICT_EQUALS,\n\tEACH_ITEM_REACTIVE,\n\tEACH_KEYED,\n\tHYDRATION_END_ELSE,\n\tHYDRATION_START\n} from '../../../../constants.js';\nimport {\n\thydrate_anchor,\n\thydrate_nodes,\n\thydrate_start,\n\thydrating,\n\tset_hydrating\n} from '../hydration.js';\nimport { clear_text_content, empty } from '../operations.js';\nimport { remove } from '../reconciler.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, set } from '../../reactivity/sources.js';\nimport { is_array, is_frozen } from '../../utils.js';\nimport { INERT, STATE_SYMBOL } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {import('#client').EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {import('#client').EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {import('#client').EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, import(\"#client\").EachItem>} items_map\n */\nfunction pause_effects(items, controlled_anchor, items_map) {\n\t/** @type {import('#client').TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: import('#client').MaybeSource<V>, index: import('#client').MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(anchor, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\t/** @type {import('#client').EachState} */\n\tvar state = { flags, items: new Map(), next: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (anchor);\n\n\t\tanchor = hydrating\n\t\t\t? /** @type {Comment | Text} */ (\n\t\t\t\t\thydrate_anchor(/** @type {Comment | Text} */ (parent_node.firstChild))\n\t\t\t\t)\n\t\t\t: parent_node.appendChild(empty());\n\t}\n\n\t/** @type {import('#client').Effect | null} */\n\tvar fallback = null;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: Array.from(collection);\n\n\t\tvar length = array.length;\n\n\t\t// If we are working with an array that isn't proxied or frozen, then remove strict equality and ensure the items\n\t\t// are treated as reactive, so they get wrapped in a signal.\n\t\tvar flags = state.flags;\n\t\tif ((flags & EACH_IS_STRICT_EQUALS) !== 0 && !is_frozen(array) && !(STATE_SYMBOL in array)) {\n\t\t\tflags ^= EACH_IS_STRICT_EQUALS;\n\n\t\t\t// Additionally if we're in an keyed each block, we'll need ensure the items are all wrapped in signals.\n\t\t\tif ((flags & EACH_KEYED) !== 0 && (flags & EACH_ITEM_REACTIVE) === 0) {\n\t\t\t\tflags ^= EACH_ITEM_REACTIVE;\n\t\t\t}\n\t\t}\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_END_ELSE;\n\n\t\t\tif (is_else !== (length === 0) || hydrate_start === undefined) {\n\t\t\t\t// hydration mismatch â€” remove the server-rendered DOM and start over\n\t\t\t\tremove(hydrate_nodes);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {Node} */\n\t\t\tvar child_anchor = hydrate_start;\n\n\t\t\t/** @type {import('#client').EachItem | import('#client').EachState} */\n\t\t\tvar prev = state;\n\n\t\t\t/** @type {import('#client').EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\tchild_anchor.nodeType !== 8 ||\n\t\t\t\t\t/** @type {Comment} */ (child_anchor).data !== HYDRATION_START\n\t\t\t\t) {\n\t\t\t\t\t// If `nodes` is null, then that means that the server rendered fewer items than what\n\t\t\t\t\t// expected, so break out and continue appending non-hydrated items\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild_anchor = hydrate_anchor(child_anchor);\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(child_anchor, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\t\t\t\tchild_anchor = /** @type {Comment} */ (child_anchor.nextSibling);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\twhile (child_anchor !== anchor) {\n\t\t\t\t\tvar next = /** @type {import('#client').TemplateNode} */ (child_anchor.nextSibling);\n\t\t\t\t\t/** @type {import('#client').TemplateNode} */ (child_anchor).remove();\n\t\t\t\t\tchild_anchor = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Array<V>} array\n * @param {import('#client').EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: import('#client').MaybeSource<V>, index: number | import('#client').Source<number>) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.next;\n\tvar current = first;\n\n\t/** @type {Set<import('#client').EachItem>} */\n\tvar seen = new Set();\n\n\t/** @type {import('#client').EachState | import('#client').EachItem} */\n\tvar prev = state;\n\n\t/** @type {Set<import('#client').EachItem>} */\n\tvar to_animate = new Set();\n\n\t/** @type {import('#client').EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {import('#client').EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {import('#client').EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\tto_animate.add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? get_first_node(current.e) : anchor;\n\n\t\t\tprev = create_item(child_anchor, prev, prev.next, value, key, i, render_fn, flags);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\tto_animate.delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(a.prev, b.next);\n\t\t\t\t\tlink(prev, a);\n\t\t\t\t\tlink(b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(item.prev, item.next);\n\t\t\t\t\tlink(item, prev.next);\n\t\t\t\t\tlink(prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\tseen.add(current);\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tconst to_destroy = Array.from(seen);\n\n\twhile (current !== null) {\n\t\tto_destroy.push(current);\n\t\tcurrent = current.next;\n\t}\n\tvar destroy_length = to_destroy.length;\n\n\tif (destroy_length > 0) {\n\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\tif (is_animated) {\n\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t}\n\n\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t}\n\t\t}\n\n\t\tpause_effects(to_destroy, controlled_anchor, items);\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {import('#client').EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tset(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tset(/** @type {import('#client').Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {import('#client').EachItem | import('#client').EachState} prev\n * @param {import('#client').EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | import('#client').Source<V>, index: number | import('#client').Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {import('#client').EachItem}\n */\nfunction create_item(anchor, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\n\ttry {\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\t\tvar mutable = (flags & EACH_IS_STRICT_EQUALS) === 0;\n\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t\t/** @type {import('#client').EachItem} */\n\t\tvar item = {\n\t\t\ti,\n\t\t\tv,\n\t\t\tk: key,\n\t\t\ta: null,\n\t\t\t// @ts-expect-error\n\t\t\te: null,\n\t\t\tprev,\n\t\t\tnext\n\t\t};\n\n\t\tprev.next = item;\n\t\tif (next !== null) next.prev = item;\n\n\t\tcurrent_each_item = item;\n\t\titem.e = branch(() => render_fn(anchor, v, i));\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {import('#client').TemplateNode} dom\n * @param {import(\"#client\").Effect} effect\n * @returns {import('#client').TemplateNode}\n */\nfunction get_adjusted_first_node(dom, effect) {\n\tif ((dom.nodeType === 3 && /** @type {Text} */ (dom).data === '') || dom.nodeType === 8) {\n\t\tvar adjusted = effect.first;\n\t\tvar next;\n\t\twhile (adjusted !== null) {\n\t\t\tnext = adjusted.first;\n\t\t\tif (adjusted.dom !== null) {\n\t\t\t\tbreak;\n\t\t\t} else if (next === null) {\n\t\t\t\treturn /** @type {import('#client').TemplateNode} */ (dom.previousSibling);\n\t\t\t}\n\t\t\tadjusted = next;\n\t\t}\n\t\treturn get_first_node(/** @type {import(\"#client\").Effect} */ (adjusted));\n\t}\n\treturn dom;\n}\n\n/**\n *\n * @param {import('#client').Effect} effect\n * @returns {import('#client').TemplateNode}\n */\nfunction get_first_node(effect) {\n\tvar dom = effect.dom;\n\tif (is_array(dom)) {\n\t\treturn get_adjusted_first_node(dom[0], effect);\n\t}\n\treturn get_adjusted_first_node(/** @type {import('#client').TemplateNode} **/ (dom), effect);\n}\n\n/**\n * @param {import('#client').EachItem} item\n * @param {import('#client').EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? get_first_node(item.next.e) : anchor;\n\tvar dest = next ? get_first_node(next.e) : anchor;\n\n\tvar node = get_first_node(item.e);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {import('#client').TemplateNode} */ (node.nextSibling);\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n *\n * @param {import('#client').EachItem | import('#client').EachState} prev\n * @param {import('#client').EachItem | null} next\n */\nfunction link(prev, next) {\n\tprev.next = next;\n\tif (next !== null) next.prev = prev;\n}\n","import { namespace_svg } from '../../../../constants.js';\nimport { hydrating, set_hydrate_nodes } from '../hydration.js';\nimport { empty } from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { set_should_intro } from '../../render.js';\nimport { current_each_item, set_current_each_item } from './each.js';\nimport { current_component_context, current_effect } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { is_array } from '../../utils.js';\nimport { push_template_node } from '../template.js';\nimport { noop } from '../../../shared/utils.js';\n\n/**\n * @param {import('#client').Effect} effect\n * @param {Element} from\n * @param {Element} to\n * @returns {void}\n */\nfunction swap_block_dom(effect, from, to) {\n\tconst dom = effect.dom;\n\n\tif (is_array(dom)) {\n\t\tfor (let i = 0; i < dom.length; i++) {\n\t\t\tif (dom[i] === from) {\n\t\t\t\tdom[i] = to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (dom === from) {\n\t\teffect.dom = to;\n\t}\n}\n\n/**\n * @param {Comment | Element} node\n * @param {() => string} get_tag\n * @param {boolean} is_svg\n * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,\n * @param {undefined | (() => string)} get_namespace\n * @param {undefined | [number, number]} location\n * @returns {void}\n */\nexport function element(node, get_tag, is_svg, render_fn, get_namespace, location) {\n\tconst filename = DEV && location && current_component_context?.function.filename;\n\n\t/** @type {string | null} */\n\tlet tag;\n\n\t/** @type {string | null} */\n\tlet current_tag;\n\n\t/** @type {null | Element} */\n\tlet element = hydrating && node.nodeType === 1 ? /** @type {Element} */ (node) : null;\n\n\tlet anchor = /** @type {Comment} */ (hydrating && element ? element.nextSibling : node);\n\n\t/** @type {import('#client').Effect | null} */\n\tlet effect;\n\n\tconst parent_effect = /** @type {import('#client').Effect} */ (current_effect);\n\n\t// Remove the the hydrated effect dom entry for our dynamic element\n\tif (hydrating && is_array(parent_effect.dom)) {\n\t\tvar remove_index = parent_effect.dom.indexOf(\n\t\t\t/** @type {import('#client').TemplateNode} */ (element)\n\t\t);\n\t\tif (remove_index !== -1) {\n\t\t\tparent_effect.dom.splice(remove_index, 1);\n\t\t}\n\t}\n\n\t/**\n\t * The keyed `{#each ...}` item block, if any, that this element is inside.\n\t * We track this so we can set it when changing the element, allowing any\n\t * `animate:` directive to bind itself to the correct block\n\t */\n\tlet each_item_block = current_each_item;\n\n\tblock(() => {\n\t\tconst element_effect = /** @type {import('#client').Effect} */ (current_effect);\n\t\tconst next_tag = get_tag() || null;\n\t\tconst ns = get_namespace\n\t\t\t? get_namespace()\n\t\t\t: is_svg || next_tag === 'svg'\n\t\t\t\t? namespace_svg\n\t\t\t\t: null;\n\n\t\t// Assumption: Noone changes the namespace but not the tag (what would that even mean?)\n\t\tif (next_tag === tag) return;\n\n\t\t// See explanation of `each_item_block` above\n\t\tvar previous_each_item = current_each_item;\n\t\tset_current_each_item(each_item_block);\n\n\t\tif (effect) {\n\t\t\tif (next_tag === null) {\n\t\t\t\t// start outro\n\t\t\t\tpause_effect(effect, () => {\n\t\t\t\t\teffect = null;\n\t\t\t\t\tcurrent_tag = null;\n\t\t\t\t\telement?.remove();\n\t\t\t\t});\n\t\t\t} else if (next_tag === current_tag) {\n\t\t\t\t// same tag as is currently rendered â€” abort outro\n\t\t\t\tresume_effect(effect);\n\t\t\t} else {\n\t\t\t\t// tag is changing â€” destroy immediately, render contents without intro transitions\n\t\t\t\tdestroy_effect(effect);\n\t\t\t\tset_should_intro(false);\n\t\t\t}\n\t\t}\n\n\t\tif (next_tag && next_tag !== current_tag) {\n\t\t\teffect = branch(() => {\n\t\t\t\tconst prev_element = element;\n\t\t\t\telement = hydrating\n\t\t\t\t\t? /** @type {Element} */ (element)\n\t\t\t\t\t: ns\n\t\t\t\t\t\t? document.createElementNS(ns, next_tag)\n\t\t\t\t\t\t: document.createElement(next_tag);\n\n\t\t\t\tif (DEV && location) {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\telement.__svelte_meta = {\n\t\t\t\t\t\tloc: {\n\t\t\t\t\t\t\tfile: filename,\n\t\t\t\t\t\t\tline: location[0],\n\t\t\t\t\t\t\tcolumn: location[1]\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (prev_element && !hydrating) {\n\t\t\t\t\tswap_block_dom(element_effect, prev_element, element);\n\t\t\t\t\tprev_element.remove();\n\t\t\t\t} else {\n\t\t\t\t\tpush_template_node(element, element_effect);\n\t\t\t\t}\n\n\t\t\t\tif (render_fn) {\n\t\t\t\t\t// If hydrating, use the existing ssr comment as the anchor so that the\n\t\t\t\t\t// inner open and close methods can pick up the existing nodes correctly\n\t\t\t\t\tvar child_anchor = hydrating ? element.lastChild : element.appendChild(empty());\n\n\t\t\t\t\tif (hydrating && child_anchor) {\n\t\t\t\t\t\tset_hydrate_nodes(\n\t\t\t\t\t\t\t/** @type {import('#client').TemplateNode[]} */ ([...element.childNodes]).slice(0, -1)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// `child_anchor` is undefined if this is a void element, but we still\n\t\t\t\t\t// need to call `render_fn` in order to run actions etc. If the element\n\t\t\t\t\t// contains children, it's a user error (which is warned on elsewhere)\n\t\t\t\t\t// and the DOM will be silently discarded\n\t\t\t\t\trender_fn(element, child_anchor);\n\t\t\t\t}\n\n\t\t\t\tanchor.before(element);\n\n\t\t\t\t// See below\n\t\t\t\treturn noop;\n\t\t\t});\n\t\t}\n\n\t\ttag = next_tag;\n\t\tif (tag) current_tag = tag;\n\t\tset_should_intro(true);\n\n\t\tset_current_each_item(previous_each_item);\n\n\t\t// Inert effects are proactively detached from the effect tree. Returning a noop\n\t\t// teardown function is an easy way to ensure that this is not discarded\n\t\treturn noop;\n\t});\n}\n","import { set, source } from '../../reactivity/sources.js';\nimport { get } from '../../runtime.js';\nimport { is_array } from '../../utils.js';\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tvar s = source(0);\n\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @this {any}\n * @param {Record<string, unknown>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tvar events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[\n\t\tevent.type\n\t];\n\n\tvar callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];\n\n\tfor (var fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tfn.call(this, event);\n\t}\n}\n\n/**\n * Used to simulate `$on` on a component instance when `legacy.componentApi` is `true`\n * @param {Record<string, any>} $$props\n * @param {string} event_name\n * @param {Function} event_callback\n */\nexport function add_legacy_event_listener($$props, event_name, event_callback) {\n\t$$props.$$events ||= {};\n\t$$props.$$events[event_name] ||= [];\n\t$$props.$$events[event_name].push(event_callback);\n}\n\n/**\n * Used to simulate `$set` on a component instance when `legacy.componentApi` is `true`.\n * Needs component accessors so that it can call the setter of the prop. Therefore doesn't\n * work for updating props in `$$props` or `$$restProps`.\n * @this {Record<string, any>}\n * @param {Record<string, any>} $$new_props\n */\nexport function update_legacy_props($$new_props) {\n\tfor (var key in $$new_props) {\n\t\tif (key in this) {\n\t\t\tthis[key] = $$new_props[key];\n\t\t}\n\t}\n}\n\n/**\n * @param {Record<string, any>} $$props\n */\nexport function default_slot($$props) {\n\tvar children = $$props.$$slots?.default;\n\tif (children === true) {\n\t\treturn $$props.children;\n\t} else {\n\t\treturn children;\n\t}\n}\n"],"names":["current_each_item","set_current_each_item","item","index","_","i","pause_effects","items","controlled_anchor","items_map","transitions","length","pause_children","is_controlled","parent_node","clear_text_content","link","run_out_transitions","destroy_effect","each","anchor","flags","get_collection","get_key","render_fn","fallback_fn","state","EACH_IS_CONTROLLED","hydrating","hydrate_anchor","empty","fallback","block","collection","array","is_array","EACH_IS_STRICT_EQUALS","is_frozen","STATE_SYMBOL","EACH_KEYED","EACH_ITEM_REACTIVE","mismatch","is_else","HYDRATION_END_ELSE","hydrate_start","remove","hydrate_nodes","set_hydrating","child_anchor","prev","HYDRATION_START","value","key","create_item","next","reconcile","resume_effect","branch","pause_effect","is_animated","EACH_IS_ANIMATED","should_update","EACH_INDEX_REACTIVE","first","current","seen","to_animate","matched","stashed","_a","get_first_node","update_item","INERT","_b","start","j","a","b","move","to_destroy","destroy_length","_c","_d","queue_micro_task","type","set","previous_each_item","reactive","mutable","v","mutable_source","source","get_adjusted_first_node","dom","effect","adjusted","end","dest","node","next_node","swap_block_dom","from","to","element","get_tag","is_svg","get_namespace","location","tag","current_tag","parent_effect","current_effect","remove_index","each_item_block","element_effect","next_tag","ns","namespace_svg","set_should_intro","prev_element","push_template_node","set_hydrate_nodes","noop","bubble_event","$$props","event","events","callbacks","fn","default_slot","children"],"mappings":"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"}