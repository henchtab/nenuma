{"version":3,"file":"store.CnbCU3_O.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/elements/misc.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/elements/attributes.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/reactivity/store.js"],"sourcesContent":["import { hydrating } from '../hydration.js';\nimport { clear_text_content } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && dom.firstChild !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of, map_get, map_set } from '../../utils.js';\nimport {\n\tAttributeAliases,\n\tDelegatedEvents,\n\tis_capture_event,\n\tnamespace_svg\n} from '../../../../constants.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '../../constants.js';\nimport { queue_idle_task, queue_micro_task } from '../task.js';\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (attributes.value === (attributes.value = value)) return;\n\t// @ts-expect-error\n\telement.value = value;\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (attributes.checked === (attributes.checked = checked)) return;\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n */\nexport function set_attribute(element, attribute, value) {\n\tvalue = value == null ? null : value + '';\n\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (attribute === 'src' || attribute === 'href' || attribute === 'srcset') {\n\t\t\tcheck_src_in_dev_hydration(element, attribute, value);\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value === null) {\n\t\telement.removeAttribute(attribute);\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {any} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\tif (prop in node) {\n\t\tvar curr_val = node[prop];\n\t\tvar next_val = typeof curr_val === 'boolean' && value === '' ? true : value;\n\t\tif (typeof curr_val !== 'object' || curr_val !== next_val) {\n\t\t\tnode[prop] = next_val;\n\t\t}\n\t} else {\n\t\tset_attribute(node, prop, value);\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string, any> | undefined} prev\n * @param {Record<string, any>} next New attributes - this function mutates this object\n * @param {boolean} lowercase_attributes\n * @param {string} css_hash\n * @returns {Record<string, any>}\n */\nexport function set_attributes(element, prev, next, lowercase_attributes, css_hash) {\n\tvar has_hash = css_hash.length !== 0;\n\tvar current = prev || {};\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (has_hash && !next.class) {\n\t\tnext.class = '';\n\t}\n\n\tvar setters = map_get(setters_cache, element.nodeName);\n\tif (!setters) map_set(setters_cache, element.nodeName, (setters = get_setters(element)));\n\n\t// @ts-expect-error\n\tvar attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});\n\t/** @type {Array<[string, any, () => void]>} */\n\tvar events = [];\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = DelegatedEvents.includes(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!prev) {\n\t\t\t\t\t\tevents.push([\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t() => (current[event_handle_key] = create_event(event_name, element, handle, opts))\n\t\t\t\t\t\t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (value == null) {\n\t\t\tattributes[key] = null;\n\t\t\telement.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\telement.style.cssText = value + '';\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (key === '__value' || key === 'value') {\n\t\t\t// @ts-ignore\n\t\t\telement.value = element[key] = element.__value = value;\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (lowercase_attributes) {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\tname = AttributeAliases[name] || name;\n\t\t\t}\n\n\t\t\tif (setters.includes(name)) {\n\t\t\t\tif (hydrating && (name === 'src' || name === 'href' || name === 'srcset')) {\n\t\t\t\t\tcheck_src_in_dev_hydration(element, name, value);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[name] = value;\n\t\t\t\t}\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tif (has_hash && name === 'class') {\n\t\t\t\t\tif (value) value += ' ';\n\t\t\t\t\tvalue += css_hash;\n\t\t\t\t}\n\n\t\t\t\tset_attribute(element, name, value);\n\t\t\t}\n\t\t}\n\t}\n\n\t// On the first run, ensure that events are added after bindings so\n\t// that their listeners fire after the binding listeners\n\tif (!prev) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (!element.isConnected) return;\n\t\t\tfor (const [key, value, evt] of events) {\n\t\t\t\tif (current[key] === value) {\n\t\t\t\t\tevt();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn current;\n}\n\n/**\n * @param {Element} node\n * @param {Record<string, any> | undefined} prev\n * @param {Record<string, any>} next The new attributes - this function mutates this object\n * @param {string} css_hash\n */\nexport function set_dynamic_element_attributes(node, prev, next, css_hash) {\n\tif (node.tagName.includes('-')) {\n\t\tfor (var key in prev) {\n\t\t\tif (!(key in next)) {\n\t\t\t\tnext[key] = null;\n\t\t\t}\n\t\t}\n\n\t\tfor (key in next) {\n\t\t\tset_custom_element_data(node, key, next[key]);\n\t\t}\n\n\t\treturn next;\n\t}\n\n\treturn set_attributes(\n\t\t/** @type {Element & ElementCSSInlineStyle} */ (node),\n\t\tprev,\n\t\tnext,\n\t\tnode.namespaceURI !== namespace_svg,\n\t\tcss_hash\n\t);\n}\n\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nvar always_set_through_set_attribute = ['width', 'height'];\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\t/** @type {string[]} */\n\tvar setters = [];\n\tvar descriptors;\n\tvar proto = get_prototype_of(element);\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\twhile (proto.constructor.name !== 'Element') {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set && !always_set_through_set_attribute.includes(key)) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string | null} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value ?? '')) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset ?? '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/**\n * @param {HTMLImageElement} element\n * @returns {void}\n */\nexport function handle_lazy_img(element) {\n\t// If we're using an image that has a lazy loading attribute, we need to apply\n\t// the loading and src after the img element has been appended to the document.\n\t// Otherwise the lazy behaviour will not work due to our cloneNode heuristic for\n\t// templates.\n\tif (!hydrating && element.loading === 'lazy') {\n\t\tvar src = element.src;\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = null;\n\t\telement.loading = 'eager';\n\t\telement.removeAttribute('src');\n\t\trequestAnimationFrame(() => {\n\t\t\t// @ts-expect-error\n\t\t\tif (element[LOADING_ATTR_SYMBOL] !== 'eager') {\n\t\t\t\telement.loading = 'lazy';\n\t\t\t}\n\t\t\telement.src = src;\n\t\t});\n\t}\n}\n","import { run, run_all } from '../../../shared/utils.js';\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\nimport { current_component_context, deep_read_state, get, untrack } from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n */\nexport function init() {\n\tconst context = /** @type {import('#client').ComponentContextLegacy} */ (\n\t\tcurrent_component_context\n\t);\n\n\tconst callbacks = context.l.u;\n\tif (!callbacks) return;\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tuser_pre_effect(() => {\n\t\t\tobserve_all(context);\n\t\t\trun_all(callbacks.b);\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context);\n\t\t\trun_all(callbacks.a);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {import('#client').ComponentContextLegacy} context\n */\nfunction observe_all(context) {\n\tif (context.l.s) {\n\t\tfor (const signal of context.l.s) get(signal);\n\t}\n\n\tdeep_read_state(context.s);\n}\n","import { subscribe_to_store } from '../../../store/utils.js';\nimport { noop } from '../../shared/utils.js';\nimport { UNINITIALIZED } from '../../../constants.js';\nimport { get, untrack } from '../runtime.js';\nimport { effect } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {import('#shared').Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {import('#client').StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\t/** @type {import('#client').StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\tconst is_new = entry === undefined;\n\n\tif (is_new) {\n\t\tentry = {\n\t\t\tstore: null,\n\t\t\tlast_value: null,\n\t\t\tvalue: mutable_source(UNINITIALIZED),\n\t\t\tunsubscribe: noop\n\t\t};\n\t\tstores[store_name] = entry;\n\t}\n\n\tif (is_new || entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\t\tentry.unsubscribe = connect_store_to_signal(store, entry.value);\n\t}\n\n\tconst value = get(entry.value);\n\t// This could happen if the store was cleaned up because the component was destroyed and there's a leak on the user side.\n\t// In that case we don't want to fail with a cryptic Symbol error, but rather return the last value we got.\n\treturn value === UNINITIALIZED ? entry.last_value : value;\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {import('#shared').Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {import('#client').StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {import('#client').StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * @template V\n * @param {import('#shared').Store<V> | null | undefined} store\n * @param {import('#client').Source<V>} source\n */\nfunction connect_store_to_signal(store, source) {\n\tif (store == null) {\n\t\tset(source, undefined);\n\t\treturn noop;\n\t}\n\n\treturn subscribe_to_store(store, (v) => set(source, v));\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {import('#shared').Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {import('#client').StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tconst store = stores[store_name];\n\tif (store.store) {\n\t\tstore_set(store.store, store.value.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @param {import('#client').StoreReferencesContainer} stores\n */\nexport function unsubscribe_on_destroy(stores) {\n\ton_destroy(() => {\n\t\tlet store_name;\n\t\tfor (store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t}\n\t});\n}\n\n/**\n * Updates a store with a new value.\n * @param {import('#shared').Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function mutate_store(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {import('#shared').Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {import('#shared').Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n * @param {() => any} fn\n * @returns {void}\n */\nfunction on_destroy(fn) {\n\teffect(() => () => untrack(fn));\n}\n"],"names":["autofocus","dom","value","body","queue_micro_task","listening_to_form_reset","add_form_reset_listener","evt","e","_a","remove_input_defaults","input","hydrating","already_removed","remove_defaults","set_attribute","checked","queue_idle_task","element","attribute","attributes","LOADING_ATTR_SYMBOL","set_custom_element_data","node","prop","curr_val","next_val","set_attributes","prev","next","lowercase_attributes","css_hash","has_hash","current","key","setters","map_get","setters_cache","map_set","get_setters","events","prev_value","prefix","opts","event_handle_key","event_name","delegated","DelegatedEvents","is_capture_event","delegate","handle","create_event","name","AttributeAliases","set_dynamic_element_attributes","namespace_svg","always_set_through_set_attribute","descriptors","proto","get_prototype_of","get_descriptors","init","context","current_component_context","callbacks","user_pre_effect","observe_all","run_all","user_effect","fns","untrack","run","fn","signal","get","deep_read_state","store_get","store","store_name","stores","entry","is_new","mutable_source","UNINITIALIZED","noop","connect_store_to_signal","store_unsub","source","set","subscribe_to_store","v","store_set","unsubscribe_on_destroy","on_destroy","effect"],"mappings":"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"}