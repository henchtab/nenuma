{"version":3,"file":"shorten-address.DP79IVVu.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/timing.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/loop.js","../../../../../../../../node_modules/.pnpm/svelte@5.0.0-next.166/node_modules/svelte/src/internal/client/dom/elements/transitions.js","../../../../../../../../node_modules/.pnpm/@tanstack+query-core@5.51.1/node_modules/@tanstack/query-core/build/modern/queryObserver.js","../../../../../../../../node_modules/.pnpm/@tanstack+svelte-query@5.51.1_svelte@5.0.0-next.166/node_modules/@tanstack/svelte-query/dist/useIsRestoring.js","../../../../../../../../node_modules/.pnpm/@tanstack+svelte-query@5.51.1_svelte@5.0.0-next.166/node_modules/@tanstack/svelte-query/dist/useQueryClient.js","../../../../../../../../node_modules/.pnpm/@tanstack+svelte-query@5.51.1_svelte@5.0.0-next.166/node_modules/@tanstack/svelte-query/dist/utils.js","../../../../../../../../node_modules/.pnpm/@tanstack+svelte-query@5.51.1_svelte@5.0.0-next.166/node_modules/@tanstack/svelte-query/dist/createBaseQuery.js","../../../../../../../../node_modules/.pnpm/@tanstack+svelte-query@5.51.1_svelte@5.0.0-next.166/node_modules/@tanstack/svelte-query/dist/createQuery.js","../../../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.76.2_svelte@5.0.0-next.166/node_modules/@melt-ui/svelte/dist/internal/helpers/array.js","../../../../../../../../node_modules/.pnpm/nanoid@5.0.7/node_modules/nanoid/non-secure/index.js","../../../../../../../../node_modules/.pnpm/@melt-ui+svelte@0.76.2_svelte@5.0.0-next.166/node_modules/@melt-ui/svelte/dist/internal/helpers/id.js","../../../../../../src/lib/shorten-address.ts"],"sourcesContent":["import { noop } from '../shared/utils.js';\n\nconst is_client = typeof window !== 'undefined';\n\nconst request_animation_frame = is_client ? requestAnimationFrame : noop;\n\nconst now = is_client ? () => performance.now() : () => Date.now();\n\n/** @type {import('#client').Raf} */\nexport const raf = {\n\ttick: /** @param {any} _ */ (_) => request_animation_frame(_),\n\tnow: () => now(),\n\ttasks: new Set()\n};\n","import { raf } from './timing.js';\n\n// TODO move this into timing.js where it probably belongs\n\n/**\n * @param {number} now\n * @returns {void}\n */\nfunction run_tasks(now) {\n\traf.tasks.forEach((task) => {\n\t\tif (!task.c(now)) {\n\t\t\traf.tasks.delete(task);\n\t\t\ttask.f();\n\t\t}\n\t});\n\n\tif (raf.tasks.size !== 0) {\n\t\traf.tick(run_tasks);\n\t}\n}\n\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n * @param {import('#client').TaskCallback} callback\n * @returns {import('#client').Task}\n */\nexport function loop(callback) {\n\t/** @type {import('#client').TaskEntry} */\n\tlet task;\n\n\tif (raf.tasks.size === 0) {\n\t\traf.tick(run_tasks);\n\t}\n\n\treturn {\n\t\tpromise: new Promise((fulfill) => {\n\t\t\traf.tasks.add((task = { c: callback, f: fulfill }));\n\t\t}),\n\t\tabort() {\n\t\t\traf.tasks.delete(task);\n\t\t}\n\t};\n}\n","import { noop } from '../../../shared/utils.js';\nimport { effect } from '../../reactivity/effects.js';\nimport { current_effect, untrack } from '../../runtime.js';\nimport { raf } from '../../timing.js';\nimport { loop } from '../../loop.js';\nimport { should_intro } from '../../render.js';\nimport { is_function } from '../../utils.js';\nimport { current_each_item } from '../blocks/each.js';\nimport { TRANSITION_GLOBAL, TRANSITION_IN, TRANSITION_OUT } from '../../../../constants.js';\nimport { BLOCK_EFFECT, EFFECT_RAN, EFFECT_TRANSPARENT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {Element} element\n * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type\n * @returns {void}\n */\nfunction dispatch_event(element, type) {\n\telement.dispatchEvent(new CustomEvent(type));\n}\n\n/**\n * @param {string} style\n * @returns {string}\n */\nfunction css_style_from_camel_case(style) {\n\tconst parts = style.split('-');\n\tif (parts.length === 1) return parts[0];\n\treturn (\n\t\tparts[0] +\n\t\tparts\n\t\t\t.slice(1)\n\t\t\t.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))\n\t\t\t.join('')\n\t);\n}\n\n/**\n * @param {string} css\n * @returns {Keyframe}\n */\nfunction css_to_keyframe(css) {\n\t/** @type {Keyframe} */\n\tconst keyframe = {};\n\tconst parts = css.split(';');\n\tfor (const part of parts) {\n\t\tconst [property, value] = part.split(':');\n\t\tif (!property || value === undefined) break;\n\n\t\tconst formatted_property = css_style_from_camel_case(property.trim());\n\t\tkeyframe[formatted_property] = value.trim();\n\t}\n\treturn keyframe;\n}\n\n/** @param {number} t */\nconst linear = (t) => t;\n\n/**\n * Called inside keyed `{#each ...}` blocks (as `$.animation(...)`). This creates an animation manager\n * and attaches it to the block, so that moves can be animated following reconciliation.\n * @template P\n * @param {Element} element\n * @param {() => import('#client').AnimateFn<P | undefined>} get_fn\n * @param {(() => P) | null} get_params\n */\nexport function animation(element, get_fn, get_params) {\n\tvar item = /** @type {import('#client').EachItem} */ (current_each_item);\n\n\t/** @type {DOMRect} */\n\tvar from;\n\n\t/** @type {DOMRect} */\n\tvar to;\n\n\t/** @type {import('#client').Animation | undefined} */\n\tvar animation;\n\n\t/** @type {null | { position: string, width: string, height: string }} */\n\tvar original_styles = null;\n\n\titem.a ??= {\n\t\telement,\n\t\tmeasure() {\n\t\t\tfrom = this.element.getBoundingClientRect();\n\t\t},\n\t\tapply() {\n\t\t\tanimation?.abort();\n\n\t\t\tto = this.element.getBoundingClientRect();\n\n\t\t\tif (\n\t\t\t\tfrom.left !== to.left ||\n\t\t\t\tfrom.right !== to.right ||\n\t\t\t\tfrom.top !== to.top ||\n\t\t\t\tfrom.bottom !== to.bottom\n\t\t\t) {\n\t\t\t\tconst options = get_fn()(this.element, { from, to }, get_params?.());\n\n\t\t\t\tanimation = animate(this.element, options, undefined, 1, () => {\n\t\t\t\t\tanimation?.abort();\n\t\t\t\t\tanimation = undefined;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tfix() {\n\t\t\tvar computed_style = getComputedStyle(element);\n\n\t\t\tif (computed_style.position !== 'absolute' && computed_style.position !== 'fixed') {\n\t\t\t\tvar style = /** @type {HTMLElement | SVGElement} */ (element).style;\n\n\t\t\t\toriginal_styles = {\n\t\t\t\t\tposition: style.position,\n\t\t\t\t\twidth: style.width,\n\t\t\t\t\theight: style.height\n\t\t\t\t};\n\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.width = computed_style.width;\n\t\t\t\tstyle.height = computed_style.height;\n\t\t\t\tvar to = element.getBoundingClientRect();\n\n\t\t\t\tif (from.left !== to.left || from.top !== to.top) {\n\t\t\t\t\tvar transform = `translate(${from.left - to.left}px, ${from.top - to.top}px)`;\n\t\t\t\t\tstyle.transform = style.transform ? `${style.transform} ${transform}` : transform;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tunfix() {\n\t\t\tif (original_styles) {\n\t\t\t\tvar style = /** @type {HTMLElement | SVGElement} */ (element).style;\n\n\t\t\t\tstyle.position = original_styles.position;\n\t\t\t\tstyle.width = original_styles.width;\n\t\t\t\tstyle.height = original_styles.height;\n\t\t\t}\n\t\t}\n\t};\n\n\t// in the case of a `<svelte:element>`, it's possible for `$.animation(...)` to be called\n\t// when an animation manager already exists, if the tag changes. in that case, we need to\n\t// swap out the element rather than creating a new manager, in case it happened at the same\n\t// moment as a reconciliation\n\titem.a.element = element;\n}\n\n/**\n * Called inside block effects as `$.transition(...)`. This creates a transition manager and\n * attaches it to the current effect â€” later, inside `pause_effect` and `resume_effect`, we\n * use this to create `intro` and `outro` transitions.\n * @template P\n * @param {number} flags\n * @param {HTMLElement} element\n * @param {() => import('#client').TransitionFn<P | undefined>} get_fn\n * @param {(() => P) | null} get_params\n * @returns {void}\n */\nexport function transition(flags, element, get_fn, get_params) {\n\tvar is_intro = (flags & TRANSITION_IN) !== 0;\n\tvar is_outro = (flags & TRANSITION_OUT) !== 0;\n\tvar is_global = (flags & TRANSITION_GLOBAL) !== 0;\n\n\t/** @type {'in' | 'out' | 'both'} */\n\tvar direction = is_intro && is_outro ? 'both' : is_intro ? 'in' : 'out';\n\n\t/** @type {import('#client').AnimationConfig | ((opts: { direction: 'in' | 'out' }) => import('#client').AnimationConfig) | undefined} */\n\tvar current_options;\n\n\tvar inert = element.inert;\n\n\t/** @type {import('#client').Animation | undefined} */\n\tvar intro;\n\n\t/** @type {import('#client').Animation | undefined} */\n\tvar outro;\n\n\t/** @type {(() => void) | undefined} */\n\tvar reset;\n\n\tfunction get_options() {\n\t\t// If a transition is still ongoing, we use the existing options rather than generating\n\t\t// new ones. This ensures that reversible transitions reverse smoothly, rather than\n\t\t// jumping to a new spot because (for example) a different `duration` was used\n\t\treturn (current_options ??= get_fn()(element, get_params?.(), { direction }));\n\t}\n\n\t/** @type {import('#client').TransitionManager} */\n\tvar transition = {\n\t\tis_global,\n\t\tin() {\n\t\t\telement.inert = inert;\n\n\t\t\tif (is_intro) {\n\t\t\t\tdispatch_event(element, 'introstart');\n\t\t\t\tintro = animate(element, get_options(), outro, 1, () => {\n\t\t\t\t\tdispatch_event(element, 'introend');\n\t\t\t\t\tintro = current_options = undefined;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\toutro?.abort();\n\t\t\t\treset?.();\n\t\t\t}\n\t\t},\n\t\tout(fn) {\n\t\t\tif (is_outro) {\n\t\t\t\telement.inert = true;\n\n\t\t\t\tdispatch_event(element, 'outrostart');\n\t\t\t\toutro = animate(element, get_options(), intro, 0, () => {\n\t\t\t\t\tdispatch_event(element, 'outroend');\n\t\t\t\t\toutro = current_options = undefined;\n\t\t\t\t\tfn?.();\n\t\t\t\t});\n\n\t\t\t\t// TODO arguably the outro should never null itself out until _all_ outros for this effect have completed...\n\t\t\t\t// in that case we wouldn't need to store `reset` separately\n\t\t\t\treset = outro.reset;\n\t\t\t} else {\n\t\t\t\tfn?.();\n\t\t\t}\n\t\t},\n\t\tstop: () => {\n\t\t\tintro?.abort();\n\t\t\toutro?.abort();\n\t\t}\n\t};\n\n\tvar e = /** @type {import('#client').Effect} */ (current_effect);\n\n\t(e.transitions ??= []).push(transition);\n\n\t// if this is a local transition, we only want to run it if the parent (branch) effect's\n\t// parent (block) effect is where the state change happened. we can determine that by\n\t// looking at whether the block effect is currently initializing\n\tif (is_intro && should_intro) {\n\t\tlet run = is_global;\n\n\t\tif (!run) {\n\t\t\tvar block = /** @type {import('#client').Effect | null} */ (e.parent);\n\n\t\t\t// skip over transparent blocks (e.g. snippets, else-if blocks)\n\t\t\twhile (block && (block.f & EFFECT_TRANSPARENT) !== 0) {\n\t\t\t\twhile ((block = block.parent)) {\n\t\t\t\t\tif ((block.f & BLOCK_EFFECT) !== 0) break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trun = !block || (block.f & EFFECT_RAN) !== 0;\n\t\t}\n\n\t\tif (run) {\n\t\t\teffect(() => {\n\t\t\t\tuntrack(() => transition.in());\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * Animates an element, according to the provided configuration\n * @param {Element} element\n * @param {import('#client').AnimationConfig | ((opts: { direction: 'in' | 'out' }) => import('#client').AnimationConfig)} options\n * @param {import('#client').Animation | undefined} counterpart The corresponding intro/outro to this outro/intro\n * @param {number} t2 The target `t` value â€” `1` for intro, `0` for outro\n * @param {(() => void) | undefined} callback\n * @returns {import('#client').Animation}\n */\nfunction animate(element, options, counterpart, t2, callback) {\n\tif (is_function(options)) {\n\t\t// In the case of a deferred transition (such as `crossfade`), `option` will be\n\t\t// a function rather than an `AnimationConfig`. We need to call this function\n\t\t// once DOM has been updated...\n\t\t/** @type {import('#client').Animation} */\n\t\tvar a;\n\n\t\tqueue_micro_task(() => {\n\t\t\tvar o = options({ direction: t2 === 1 ? 'in' : 'out' });\n\t\t\ta = animate(element, o, counterpart, t2, callback);\n\t\t});\n\n\t\t// ...but we want to do so without using `async`/`await` everywhere, so\n\t\t// we return a facade that allows everything to remain synchronous\n\t\treturn {\n\t\t\tabort: () => a.abort(),\n\t\t\tdeactivate: () => a.deactivate(),\n\t\t\treset: () => a.reset(),\n\t\t\tt: (now) => a.t(now)\n\t\t};\n\t}\n\n\tcounterpart?.deactivate();\n\n\tif (!options?.duration) {\n\t\tcallback?.();\n\t\treturn {\n\t\t\tabort: noop,\n\t\t\tdeactivate: noop,\n\t\t\treset: noop,\n\t\t\tt: () => t2\n\t\t};\n\t}\n\n\tvar { delay = 0, duration, css, tick, easing = linear } = options;\n\n\tvar start = raf.now() + delay;\n\tvar t1 = counterpart?.t(start) ?? 1 - t2;\n\tvar delta = t2 - t1;\n\n\tduration *= Math.abs(delta);\n\tvar end = start + duration;\n\n\t/** @type {Animation} */\n\tvar animation;\n\n\t/** @type {import('#client').Task} */\n\tvar task;\n\n\tif (css) {\n\t\t// WAAPI\n\t\tvar keyframes = [];\n\t\tvar n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value\n\n\t\tfor (var i = 0; i <= n; i += 1) {\n\t\t\tvar t = t1 + delta * easing(i / n);\n\t\t\tvar styles = css(t, 1 - t);\n\t\t\tkeyframes.push(css_to_keyframe(styles));\n\t\t}\n\n\t\tanimation = element.animate(keyframes, {\n\t\t\tdelay,\n\t\t\tduration,\n\t\t\teasing: 'linear',\n\t\t\tfill: 'forwards'\n\t\t});\n\n\t\tanimation.finished\n\t\t\t.then(() => {\n\t\t\t\tcallback?.();\n\n\t\t\t\tif (t2 === 1) {\n\t\t\t\t\tanimation.cancel();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((e) => {\n\t\t\t\t// Error for DOMException: The user aborted a request. This results in two things:\n\t\t\t\t// - startTime is `null`\n\t\t\t\t// - currentTime is `null`\n\t\t\t\t// We can't use the existence of an AbortError as this error and error code is shared\n\t\t\t\t// with other Web APIs such as fetch().\n\n\t\t\t\tif (animation.startTime !== null && animation.currentTime !== null) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t});\n\t} else {\n\t\t// Timer\n\t\tif (t1 === 0) {\n\t\t\ttick?.(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?\n\t\t}\n\n\t\ttask = loop((now) => {\n\t\t\tif (now >= end) {\n\t\t\t\ttick?.(t2, 1 - t2);\n\t\t\t\tcallback?.();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (now >= start) {\n\t\t\t\tvar p = t1 + delta * easing((now - start) / duration);\n\t\t\t\ttick?.(p, 1 - p);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\treturn {\n\t\tabort: () => {\n\t\t\tanimation?.cancel();\n\t\t\ttask?.abort();\n\t\t},\n\t\tdeactivate: () => {\n\t\t\tcallback = undefined;\n\t\t},\n\t\treset: () => {\n\t\t\tif (t2 === 0) {\n\t\t\t\ttick?.(1, 0);\n\t\t\t}\n\t\t},\n\t\tt: (now) => {\n\t\t\tvar t = t1 + delta * easing((now - start) / duration);\n\t\t\treturn Math.min(1, Math.max(0, t));\n\t\t}\n\t};\n}\n","// src/queryObserver.ts\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { fetchState } from \"./query.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(newState.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","import { getIsRestoringContext } from './context';\nexport function useIsRestoring() {\n    return getIsRestoringContext();\n}\n","import { getQueryClientContext } from './context';\nexport function useQueryClient(queryClient) {\n    if (queryClient)\n        return queryClient;\n    return getQueryClientContext();\n}\n","export function isSvelteStore(obj) {\n    return 'subscribe' in obj && typeof obj.subscribe === 'function';\n}\nexport function noop() { }\n","import { derived, get, readable } from 'svelte/store';\nimport { notifyManager } from '@tanstack/query-core';\nimport { useIsRestoring } from './useIsRestoring';\nimport { useQueryClient } from './useQueryClient';\nimport { isSvelteStore } from './utils';\nexport function createBaseQuery(options, Observer, queryClient) {\n    /** Load query client */\n    const client = useQueryClient(queryClient);\n    const isRestoring = useIsRestoring();\n    /** Converts options to a svelte store if not already a store object */\n    const optionsStore = isSvelteStore(options) ? options : readable(options);\n    /** Creates a store that has the default options applied */\n    const defaultedOptionsStore = derived([optionsStore, isRestoring], ([$optionsStore, $isRestoring]) => {\n        const defaultedOptions = client.defaultQueryOptions($optionsStore);\n        defaultedOptions._optimisticResults = $isRestoring\n            ? 'isRestoring'\n            : 'optimistic';\n        return defaultedOptions;\n    });\n    /** Creates the observer */\n    const observer = new Observer(client, get(defaultedOptionsStore));\n    defaultedOptionsStore.subscribe(($defaultedOptions) => {\n        // Do not notify on updates because of changes in the options because\n        // these changes should already be reflected in the optimistic result.\n        observer.setOptions($defaultedOptions, { listeners: false });\n    });\n    const result = derived(isRestoring, ($isRestoring, set) => {\n        const unsubscribe = $isRestoring\n            ? () => undefined\n            : observer.subscribe(notifyManager.batchCalls(set));\n        observer.updateResult();\n        return unsubscribe;\n    });\n    /** Subscribe to changes in result and defaultedOptionsStore */\n    const { subscribe } = derived([result, defaultedOptionsStore], ([$result, $defaultedOptionsStore]) => {\n        $result = observer.getOptimisticResult($defaultedOptionsStore);\n        return !$defaultedOptionsStore.notifyOnChangeProps\n            ? observer.trackResult($result)\n            : $result;\n    });\n    return { subscribe };\n}\n","import { QueryObserver } from '@tanstack/query-core';\nimport { createBaseQuery } from './createBaseQuery';\nexport function createQuery(options, queryClient) {\n    return createBaseQuery(options, QueryObserver, queryClient);\n}\n","import { dequal as deepEqual } from 'dequal';\n/**\n * Returns the element some number before the given index. If the target index is out of bounds:\n *   - If looping is disabled, the first element will be returned.\n *   - If looping is enabled, the last element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function back(array, index, increment, loop = true) {\n    const previousIndex = index - increment;\n    if (previousIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[previousIndex];\n}\n/**\n * Returns the element some number after the given index. If the target index is out of bounds:\n *   - If looping is disabled, the last element will be returned.\n *   - If looping is enabled, the first element will be returned.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param increment the number of elements to move forward.\n * @param loop loop to the beginning of the array if the target index is out of bounds?\n */\nexport function forward(array, index, increment, loop = true) {\n    const nextIndex = index + increment;\n    if (nextIndex > array.length - 1) {\n        return loop ? array[0] : array[array.length - 1];\n    }\n    return array[nextIndex];\n}\n/**\n * Returns the array element after to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the beginning of the array if the next index is out of bounds?\n */\nexport function next(array, index, loop = true) {\n    if (index === array.length - 1) {\n        return loop ? array[0] : array[index];\n    }\n    return array[index + 1];\n}\n/**\n * Returns the array element prior to the given index.\n * @param array the array.\n * @param currentIndex the index of the current element.\n * @param loop loop to the end of the array if the previous index is out of bounds?\n */\nexport function prev(array, currentIndex, loop = true) {\n    if (currentIndex <= 0) {\n        return loop ? array[array.length - 1] : array[0];\n    }\n    return array[currentIndex - 1];\n}\n/**\n * Returns the last element in an array.\n * @param array the array.\n */\nexport function last(array) {\n    return array[array.length - 1];\n}\n/**\n * Wraps an array around itself at a given starting index.\n * @example ```ts\n * wrapArray(['a', 'b', 'c', 'd'], 2);\n * // ['c', 'd', 'a', 'b']\n * ```\n * @see https://github.com/radix-ui/primitives\n */\nexport function wrapArray(array, startIndex) {\n    return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n/**\n * Toggles an item in an array. If the item is already in the array,\n * it is removed. Otherwise, it is added.\n * @param item The item to toggle.\n * @param array The array to toggle the item in.\n * @returns The updated array with the item toggled.\n * @template T The type of the items in the array.\n * @example ```typescript\n * const arr = [1, 2, 3];\n * const newArr = toggle(2, arr);\n * // newArr = [1, 3]\n * ```\n */\nexport function toggle(item, array, compare = deepEqual) {\n    const itemIdx = array.findIndex((innerItem) => compare(innerItem, item));\n    if (itemIdx !== -1) {\n        array.splice(itemIdx, 1);\n    }\n    else {\n        array.push(item);\n    }\n    return array;\n}\n/**\n * Splits an array into chunks of a given size.\n * @param arr The array to split.\n * @param size The size of each chunk.\n * @returns An array of arrays, where each sub-array has `size` elements from the original array.\n * @example ```ts\n * const arr = [1, 2, 3, 4, 5, 6, 7, 8];\n * const chunks = chunk(arr, 3);\n * // chunks = [[1, 2, 3], [4, 5, 6], [7, 8]]\n * ```\n */\nexport function chunk(arr, size) {\n    const result = [];\n    for (let i = 0; i < arr.length; i += size) {\n        result.push(arr.slice(i, i + size));\n    }\n    return result;\n}\n/**\n * Checks if the given index is valid for the given array.\n *\n * @param index - The index to check\n * @param arr - The array to check\n */\nexport function isValidIndex(index, arr) {\n    return index >= 0 && index < arr.length;\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n","import { nanoid } from 'nanoid/non-secure';\n/**\n * A function that generates a random id\n * @returns An id\n */\nexport function generateId() {\n    return nanoid(10);\n}\nexport function generateIds(args) {\n    return args.reduce((acc, curr) => {\n        acc[curr] = generateId();\n        return acc;\n    }, {});\n}\nexport function stringifiedIdObjType(args) {\n    return `Record<${args.map((arg) => `\"${arg}\"`).join(' | ')}, string>`;\n}\n","import { Address } from '@ton/ton';\n\nclass InvalidAddressError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InvalidAddressError';\n  }\n}\n\nconst addressFormatOptions = {\n  testOnly: true,\n  bounceable: false\n};\n\nfunction formatAddressString(\n  addressString: string,\n  prefixLength: number,\n  suffixLength: number\n): string {\n  return `${addressString.slice(0, prefixLength)}...${addressString.slice(-suffixLength)}`;\n}\n\nfunction getAddressString(address: string | Address): string {\n  if (Address.isAddress(address)) {\n    return address.toString(addressFormatOptions);\n  }\n\n  try {\n    return Address.parse(address).toString(addressFormatOptions);\n  } catch (error) {\n    throw new InvalidAddressError(`${address} is not a valid address.`);\n  }\n}\n\nexport function shortenAddress(\n  address: string | Address,\n  prefixLength: number = 6,\n  suffixLength: number = 6\n): string {\n  const addressString = getAddressString(address);\n  return formatAddressString(addressString, prefixLength, suffixLength);\n}\n"],"names":["is_client","request_animation_frame","noop","now","raf","_","run_tasks","task","loop","callback","fulfill","dispatch_event","element","type","css_style_from_camel_case","style","parts","word","css_to_keyframe","css","keyframe","part","property","value","formatted_property","linear","t","transition","flags","get_fn","get_params","is_intro","TRANSITION_IN","is_outro","TRANSITION_OUT","is_global","TRANSITION_GLOBAL","direction","current_options","inert","intro","outro","reset","get_options","animate","fn","e","current_effect","should_intro","run","block","EFFECT_TRANSPARENT","BLOCK_EFFECT","EFFECT_RAN","effect","untrack","options","counterpart","t2","is_function","a","queue_micro_task","o","delay","duration","tick","easing","start","t1","delta","end","animation","keyframes","n","i","styles","p","QueryObserver","_a","Subscribable","client","__privateAdd","_QueryObserver_instances","_client","_currentQuery","_currentQueryInitialState","_currentResult","_currentResultState","_currentResultOptions","_selectError","_selectFn","_selectResult","_lastQueryWithDefinedData","_staleTimeoutId","_refetchIntervalId","_currentRefetchInterval","_trackedProps","__privateSet","__privateGet","shouldFetchOnMount","__privateMethod","executeFetch_fn","updateTimers_fn","shouldFetchOn","clearStaleTimeout_fn","clearRefetchInterval_fn","notifyOptions","prevOptions","prevQuery","resolveEnabled","updateQuery_fn","shallowEqualObjects","mounted","shouldFetchOptionally","resolveStaleTime","updateStaleTimeout_fn","nextRefetchInterval","computeRefetchInterval_fn","updateRefetchInterval_fn","query","result","shouldAssignObserverCurrentProperties","onPropTracked","trackedResult","key","defaultedOptions","fetchOptions","prevResult","prevResultState","prevResultOptions","queryInitialState","state","newState","isPlaceholderData","data","fetchOnMount","fetchOptionally","fetchState","error","errorUpdatedAt","status","replaceData","selectError","placeholderData","isFetching","isPending","isError","isLoading","hasData","isStale","nextResult","defaultNotifyOptions","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","typedKey","notify_fn","promise","staleTime","isServer","isValidTimeout","timeout","timeUntilStale","nextInterval","focusManager","notifyManager","listener","shouldLoadOnMount","field","observer","optimisticResult","useIsRestoring","getIsRestoringContext","useQueryClient","queryClient","getQueryClientContext","isSvelteStore","obj","createBaseQuery","Observer","isRestoring","optionsStore","readable","defaultedOptionsStore","derived","$optionsStore","$isRestoring","get","$defaultedOptions","set","unsubscribe","subscribe","$result","$defaultedOptionsStore","createQuery","next","array","index","prev","currentIndex","last","urlAlphabet","nanoid","size","id","generateId","generateIds","args","acc","curr","InvalidAddressError","message","addressFormatOptions","formatAddressString","addressString","prefixLength","suffixLength","getAddressString","address","Address","shortenAddress"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}